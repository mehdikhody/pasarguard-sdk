/* tslint:disable */
/* eslint-disable */
/**
 * PasarGuardAPI
 * Unified GUI Censorship Resistant Solution
 *
 * The version of the OpenAPI document: 1.11.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Conflict,
  Forbidden,
  HTTPValidationError,
  NodeCoreUpdate,
  NodeCreate,
  NodeGeoFilesUpdate,
  NodeModify,
  NodeRealtimeStats,
  NodeResponse,
  NodeSettings,
  NodeStatsList,
  NodeStatus,
  NodeUsageStatsList,
  NodesResponse,
  Period,
  ResponseRealtimeNodesStatsApiNodesRealtimeStatsGetValue,
  Unauthorized,
  UsageTable,
  UserIPList,
  UserIPListAll,
} from '../models/index';
import {
    ConflictFromJSON,
    ConflictToJSON,
    ForbiddenFromJSON,
    ForbiddenToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    NodeCoreUpdateFromJSON,
    NodeCoreUpdateToJSON,
    NodeCreateFromJSON,
    NodeCreateToJSON,
    NodeGeoFilesUpdateFromJSON,
    NodeGeoFilesUpdateToJSON,
    NodeModifyFromJSON,
    NodeModifyToJSON,
    NodeRealtimeStatsFromJSON,
    NodeRealtimeStatsToJSON,
    NodeResponseFromJSON,
    NodeResponseToJSON,
    NodeSettingsFromJSON,
    NodeSettingsToJSON,
    NodeStatsListFromJSON,
    NodeStatsListToJSON,
    NodeStatusFromJSON,
    NodeStatusToJSON,
    NodeUsageStatsListFromJSON,
    NodeUsageStatsListToJSON,
    NodesResponseFromJSON,
    NodesResponseToJSON,
    PeriodFromJSON,
    PeriodToJSON,
    ResponseRealtimeNodesStatsApiNodesRealtimeStatsGetValueFromJSON,
    ResponseRealtimeNodesStatsApiNodesRealtimeStatsGetValueToJSON,
    UnauthorizedFromJSON,
    UnauthorizedToJSON,
    UsageTableFromJSON,
    UsageTableToJSON,
    UserIPListFromJSON,
    UserIPListToJSON,
    UserIPListAllFromJSON,
    UserIPListAllToJSON,
} from '../models/index';

export interface ClearUsageDataRequest {
    table: UsageTable;
    start?: Date | null;
    end?: Date | null;
}

export interface CreateNodeRequest {
    nodeCreate: NodeCreate;
}

export interface GetNodeRequest {
    nodeId: number;
}

export interface GetNodeStatsPeriodicRequest {
    nodeId: number;
    start?: Date | null;
    end?: Date | null;
    period?: Period;
}

export interface GetNodesRequest {
    coreId?: number | null;
    offset?: number | null;
    limit?: number | null;
    status?: Array<NodeStatus> | null;
    enabled?: boolean;
    ids?: Array<number> | null;
    search?: string | null;
}

export interface GetUsageRequest {
    start?: Date | null;
    end?: Date | null;
    period?: Period;
    nodeId?: number | null;
    groupByNode?: boolean;
}

export interface ModifyNodeRequest {
    nodeId: number;
    nodeModify: NodeModify;
}

export interface NodeLogsRequest {
    nodeId: number;
}

export interface RealtimeNodeStatsRequest {
    nodeId: number;
}

export interface ReconnectAllNodeRequest {
    coreId?: number | null;
}

export interface ReconnectNodeRequest {
    nodeId: number;
}

export interface RemoveNodeRequest {
    nodeId: number;
}

export interface ResetNodeUsageRequest {
    nodeId: number;
}

export interface SyncNodeRequest {
    nodeId: number;
    flushUsers?: boolean;
}

export interface UpdateCoreRequest {
    nodeId: number;
    nodeCoreUpdate: NodeCoreUpdate;
}

export interface UpdateGeofilesRequest {
    nodeId: number;
    nodeGeoFilesUpdate: NodeGeoFilesUpdate;
}

export interface UpdateNodeRequest {
    nodeId: number;
}

export interface UserOnlineIpListRequest {
    nodeId: number;
    username: string;
}

export interface UserOnlineIpListAllNodesRequest {
    username: string;
}

export interface UserOnlineStatsRequest {
    nodeId: number;
    username: string;
}

/**
 * 
 */
export class NodeApi extends runtime.BaseAPI {

    /**
     * Deletes **all rows** from the selected usage data table. Use with caution.  Allowed tables:     - `node_user_usages`: Deletes user-specific node usage traffic records.     - `node_usages`: Deletes node-level aggregated traffic (uplink/downlink) records.  **Optional filters:**     - `start`: ISO 8601 timestamp to filter from (inclusive)     - `end`: ISO 8601 timestamp to filter to (exclusive)  ⚠️ This operation is irreversible. Ensure correct usage in production environments.
     * Clear usage data from a specified table
     */
    async clearUsageDataRaw(requestParameters: ClearUsageDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['table'] == null) {
            throw new runtime.RequiredError(
                'table',
                'Required parameter "table" was null or undefined when calling clearUsageData().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = (requestParameters['start'] as any).toISOString();
        }

        if (requestParameters['end'] != null) {
            queryParameters['end'] = (requestParameters['end'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/nodes/clear_usage_data/{table}`.replace(`{${"table"}}`, encodeURIComponent(String(requestParameters['table']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Deletes **all rows** from the selected usage data table. Use with caution.  Allowed tables:     - `node_user_usages`: Deletes user-specific node usage traffic records.     - `node_usages`: Deletes node-level aggregated traffic (uplink/downlink) records.  **Optional filters:**     - `start`: ISO 8601 timestamp to filter from (inclusive)     - `end`: ISO 8601 timestamp to filter to (exclusive)  ⚠️ This operation is irreversible. Ensure correct usage in production environments.
     * Clear usage data from a specified table
     */
    async clearUsageData(requestParameters: ClearUsageDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.clearUsageDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new node to the database.
     * Create Node
     */
    async createNodeRaw(requestParameters: CreateNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NodeResponse>> {
        if (requestParameters['nodeCreate'] == null) {
            throw new runtime.RequiredError(
                'nodeCreate',
                'Required parameter "nodeCreate" was null or undefined when calling createNode().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NodeCreateToJSON(requestParameters['nodeCreate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeResponseFromJSON(jsonValue));
    }

    /**
     * Create a new node to the database.
     * Create Node
     */
    async createNode(requestParameters: CreateNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NodeResponse> {
        const response = await this.createNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve details of a specific node by its ID.
     * Get Node
     */
    async getNodeRaw(requestParameters: GetNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NodeResponse>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling getNode().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve details of a specific node by its ID.
     * Get Node
     */
    async getNode(requestParameters: GetNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NodeResponse> {
        const response = await this.getNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the current node settings.
     * Get Node Settings
     */
    async getNodeSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NodeSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeSettingsFromJSON(jsonValue));
    }

    /**
     * Retrieve the current node settings.
     * Get Node Settings
     */
    async getNodeSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NodeSettings> {
        const response = await this.getNodeSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get Node Stats Periodic
     */
    async getNodeStatsPeriodicRaw(requestParameters: GetNodeStatsPeriodicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NodeStatsList>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling getNodeStatsPeriodic().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = (requestParameters['start'] as any).toISOString();
        }

        if (requestParameters['end'] != null) {
            queryParameters['end'] = (requestParameters['end'] as any).toISOString();
        }

        if (requestParameters['period'] != null) {
            queryParameters['period'] = requestParameters['period'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/stats`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeStatsListFromJSON(jsonValue));
    }

    /**
     * Get Node Stats Periodic
     */
    async getNodeStatsPeriodic(requestParameters: GetNodeStatsPeriodicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NodeStatsList> {
        const response = await this.getNodeStatsPeriodicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of all nodes. Accessible only to sudo admins.
     * Get Nodes
     */
    async getNodesRaw(requestParameters: GetNodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NodesResponse>> {
        const queryParameters: any = {};

        if (requestParameters['coreId'] != null) {
            queryParameters['core_id'] = requestParameters['coreId'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['enabled'] != null) {
            queryParameters['enabled'] = requestParameters['enabled'];
        }

        if (requestParameters['ids'] != null) {
            queryParameters['ids'] = requestParameters['ids'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/nodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NodesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all nodes. Accessible only to sudo admins.
     * Get Nodes
     */
    async getNodes(requestParameters: GetNodesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NodesResponse> {
        const response = await this.getNodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve usage statistics for nodes within a specified date range.
     * Get Usage
     */
    async getUsageRaw(requestParameters: GetUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NodeUsageStatsList>> {
        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = (requestParameters['start'] as any).toISOString();
        }

        if (requestParameters['end'] != null) {
            queryParameters['end'] = (requestParameters['end'] as any).toISOString();
        }

        if (requestParameters['period'] != null) {
            queryParameters['period'] = requestParameters['period'];
        }

        if (requestParameters['nodeId'] != null) {
            queryParameters['node_id'] = requestParameters['nodeId'];
        }

        if (requestParameters['groupByNode'] != null) {
            queryParameters['group_by_node'] = requestParameters['groupByNode'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/usage`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeUsageStatsListFromJSON(jsonValue));
    }

    /**
     * Retrieve usage statistics for nodes within a specified date range.
     * Get Usage
     */
    async getUsage(requestParameters: GetUsageRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NodeUsageStatsList> {
        const response = await this.getUsageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify a node\'s details. Only accessible to sudo admins.
     * Modify Node
     */
    async modifyNodeRaw(requestParameters: ModifyNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NodeResponse>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling modifyNode().'
            );
        }

        if (requestParameters['nodeModify'] == null) {
            throw new runtime.RequiredError(
                'nodeModify',
                'Required parameter "nodeModify" was null or undefined when calling modifyNode().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: NodeModifyToJSON(requestParameters['nodeModify']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeResponseFromJSON(jsonValue));
    }

    /**
     * Modify a node\'s details. Only accessible to sudo admins.
     * Modify Node
     */
    async modifyNode(requestParameters: ModifyNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NodeResponse> {
        const response = await this.modifyNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stream logs for a specific node as Server-Sent Events.
     * Node Logs
     */
    async nodeLogsRaw(requestParameters: NodeLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling nodeLogs().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/logs`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Stream logs for a specific node as Server-Sent Events.
     * Node Logs
     */
    async nodeLogs(requestParameters: NodeLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.nodeLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve node real-time statistics.
     * Realtime Node Stats
     */
    async realtimeNodeStatsRaw(requestParameters: RealtimeNodeStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NodeRealtimeStats>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling realtimeNodeStats().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/realtime_stats`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeRealtimeStatsFromJSON(jsonValue));
    }

    /**
     * Retrieve node real-time statistics.
     * Realtime Node Stats
     */
    async realtimeNodeStats(requestParameters: RealtimeNodeStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NodeRealtimeStats> {
        const response = await this.realtimeNodeStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve nodes real-time statistics.
     * Realtime Nodes Stats
     */
    async realtimeNodesStatsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: ResponseRealtimeNodesStatsApiNodesRealtimeStatsGetValue; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/nodes/realtime_stats`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => runtime.mapValues(jsonValue, ResponseRealtimeNodesStatsApiNodesRealtimeStatsGetValueFromJSON));
    }

    /**
     * Retrieve nodes real-time statistics.
     * Realtime Nodes Stats
     */
    async realtimeNodesStats(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: ResponseRealtimeNodesStatsApiNodesRealtimeStatsGetValue; }> {
        const response = await this.realtimeNodesStatsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Trigger reconnection for all nodes or a specific core.
     * Reconnect All Node
     */
    async reconnectAllNodeRaw(requestParameters: ReconnectAllNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        if (requestParameters['coreId'] != null) {
            queryParameters['core_id'] = requestParameters['coreId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/nodes/reconnect`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Trigger reconnection for all nodes or a specific core.
     * Reconnect All Node
     */
    async reconnectAllNode(requestParameters: ReconnectAllNodeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.reconnectAllNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Trigger a reconnection for the specified node. Only accessible to sudo admins.
     * Reconnect Node
     */
    async reconnectNodeRaw(requestParameters: ReconnectNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling reconnectNode().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/reconnect`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Trigger a reconnection for the specified node. Only accessible to sudo admins.
     * Reconnect Node
     */
    async reconnectNode(requestParameters: ReconnectNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.reconnectNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a node and remove it from xray in the background.
     * Remove Node
     */
    async removeNodeRaw(requestParameters: RemoveNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling removeNode().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a node and remove it from xray in the background.
     * Remove Node
     */
    async removeNode(requestParameters: RemoveNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeNodeRaw(requestParameters, initOverrides);
    }

    /**
     * Reset node traffic usage (uplink and downlink). Creates a log entry in node_usage_reset_logs table. Only accessible to sudo admins.
     * Reset Node Usage
     */
    async resetNodeUsageRaw(requestParameters: ResetNodeUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NodeResponse>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling resetNodeUsage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/reset`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeResponseFromJSON(jsonValue));
    }

    /**
     * Reset node traffic usage (uplink and downlink). Creates a log entry in node_usage_reset_logs table. Only accessible to sudo admins.
     * Reset Node Usage
     */
    async resetNodeUsage(requestParameters: ResetNodeUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NodeResponse> {
        const response = await this.resetNodeUsageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sync Node
     */
    async syncNodeRaw(requestParameters: SyncNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling syncNode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['flushUsers'] != null) {
            queryParameters['flush_users'] = requestParameters['flushUsers'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/sync`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Sync Node
     */
    async syncNode(requestParameters: SyncNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.syncNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Core
     */
    async updateCoreRaw(requestParameters: UpdateCoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling updateCore().'
            );
        }

        if (requestParameters['nodeCoreUpdate'] == null) {
            throw new runtime.RequiredError(
                'nodeCoreUpdate',
                'Required parameter "nodeCoreUpdate" was null or undefined when calling updateCore().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/core_update`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NodeCoreUpdateToJSON(requestParameters['nodeCoreUpdate']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Update Core
     */
    async updateCore(requestParameters: UpdateCoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateCoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Geofiles
     */
    async updateGeofilesRaw(requestParameters: UpdateGeofilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling updateGeofiles().'
            );
        }

        if (requestParameters['nodeGeoFilesUpdate'] == null) {
            throw new runtime.RequiredError(
                'nodeGeoFilesUpdate',
                'Required parameter "nodeGeoFilesUpdate" was null or undefined when calling updateGeofiles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/geofiles`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NodeGeoFilesUpdateToJSON(requestParameters['nodeGeoFilesUpdate']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Update Geofiles
     */
    async updateGeofiles(requestParameters: UpdateGeofilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateGeofilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Node
     */
    async updateNodeRaw(requestParameters: UpdateNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling updateNode().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/update`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Update Node
     */
    async updateNode(requestParameters: UpdateNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve user ips by node.
     * User Online Ip List
     */
    async userOnlineIpListRaw(requestParameters: UserOnlineIpListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserIPList>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling userOnlineIpList().'
            );
        }

        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling userOnlineIpList().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/online_stats/{username}/ip`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))).replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserIPListFromJSON(jsonValue));
    }

    /**
     * Retrieve user ips by node.
     * User Online Ip List
     */
    async userOnlineIpList(requestParameters: UserOnlineIpListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserIPList> {
        const response = await this.userOnlineIpListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve user ips from all nodes.
     * User Online Ip List All Nodes
     */
    async userOnlineIpListAllNodesRaw(requestParameters: UserOnlineIpListAllNodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserIPListAll>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling userOnlineIpListAllNodes().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/online_stats/{username}/ip`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserIPListAllFromJSON(jsonValue));
    }

    /**
     * Retrieve user ips from all nodes.
     * User Online Ip List All Nodes
     */
    async userOnlineIpListAllNodes(requestParameters: UserOnlineIpListAllNodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserIPListAll> {
        const response = await this.userOnlineIpListAllNodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve user online stats by node.
     * User Online Stats
     */
    async userOnlineStatsRaw(requestParameters: UserOnlineStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: number | null; }>> {
        if (requestParameters['nodeId'] == null) {
            throw new runtime.RequiredError(
                'nodeId',
                'Required parameter "nodeId" was null or undefined when calling userOnlineStats().'
            );
        }

        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling userOnlineStats().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/node/{node_id}/online_stats/{username}`.replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters['nodeId']))).replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieve user online stats by node.
     * User Online Stats
     */
    async userOnlineStats(requestParameters: UserOnlineStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: number | null; }> {
        const response = await this.userOnlineStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
