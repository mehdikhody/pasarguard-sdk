/* tslint:disable */
/* eslint-disable */
/**
 * PasarGuardAPI
 * Unified GUI Censorship Resistant Solution
 *
 * The version of the OpenAPI document: 1.11.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { BulkUser } from '../models';
// @ts-ignore
import type { BulkUsersCreateResponse } from '../models';
// @ts-ignore
import type { BulkUsersFromTemplate } from '../models';
// @ts-ignore
import type { BulkUsersProxy } from '../models';
// @ts-ignore
import type { Conflict } from '../models';
// @ts-ignore
import type { CreateUserFromTemplate } from '../models';
// @ts-ignore
import type { Forbidden } from '../models';
// @ts-ignore
import type { HTTPException } from '../models';
// @ts-ignore
import type { HTTPValidationError } from '../models';
// @ts-ignore
import type { ModifyUserByTemplate } from '../models';
// @ts-ignore
import type { NotFound } from '../models';
// @ts-ignore
import type { Period } from '../models';
// @ts-ignore
import type { RemoveUsersResponse } from '../models';
// @ts-ignore
import type { Unauthorized } from '../models';
// @ts-ignore
import type { UserCreate } from '../models';
// @ts-ignore
import type { UserModify } from '../models';
// @ts-ignore
import type { UserResponse } from '../models';
// @ts-ignore
import type { UserStatus } from '../models';
// @ts-ignore
import type { UserSubscriptionUpdateChart } from '../models';
// @ts-ignore
import type { UserSubscriptionUpdateList } from '../models';
// @ts-ignore
import type { UserUsageStatsList } from '../models';
// @ts-ignore
import type { UsersResponse } from '../models';
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Reset user by next plan
         * @summary Active Next Plan
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeNextPlan: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('activeNextPlan', 'username', username)
            const localVarPath = `/api/user/{username}/active_next`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk create users from a template using configurable username strategies.  - Includes the template creation fields plus `count`, `strategy`, and `start_number` (for sequences). - **strategy**: Username generation strategy — `sequence` or `random`. - **start_number**: Optional starting suffix for `sequence` strategy. Defaults to `1` and does not parse numbers from the base username.  Returns subscription URLs for created users.
         * @summary Bulk Create Users From Template
         * @param {BulkUsersFromTemplate} bulkUsersFromTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateUsersFromTemplate: async (bulkUsersFromTemplate: BulkUsersFromTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkUsersFromTemplate' is not null or undefined
            assertParamExists('bulkCreateUsersFromTemplate', 'bulkUsersFromTemplate', bulkUsersFromTemplate)
            const localVarPath = `/api/users/bulk/from_template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUsersFromTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk modify users\' data limit based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
         * @summary Bulk sum/sub to data limit of users
         * @param {BulkUser} bulkUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkModifyUsersDatalimit: async (bulkUser: BulkUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkUser' is not null or undefined
            assertParamExists('bulkModifyUsersDatalimit', 'bulkUser', bulkUser)
            const localVarPath = `/api/users/bulk/data_limit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk expire users based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (in seconds, positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
         * @summary Bulk sum/sub to expire of users
         * @param {BulkUser} bulkUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkModifyUsersExpire: async (bulkUser: BulkUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkUser' is not null or undefined
            assertParamExists('bulkModifyUsersExpire', 'bulkUser', bulkUser)
            const localVarPath = `/api/users/bulk/expire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk modify users proxy settings
         * @param {BulkUsersProxy} bulkUsersProxy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkModifyUsersProxySettings: async (bulkUsersProxy: BulkUsersProxy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkUsersProxy' is not null or undefined
            assertParamExists('bulkModifyUsersProxySettings', 'bulkUsersProxy', bulkUsersProxy)
            const localVarPath = `/api/users/bulk/proxy_settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUsersProxy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user  - **username**: 3 to 32 characters, can include a-z, 0-9, and underscores. - **status**: User\'s status, defaults to `active`. Special rules if `on_hold`. - **expire**: UTC datetime for account expiration. Use `0` for unlimited. - **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited. - **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets. - **proxy_settings**: Dictionary of protocol settings (e.g., `vmess`, `vless`) will generate data for all protocol by default. - **group_ids**: List of group IDs to assign to the user. - **note**: Optional text field for additional user information or notes. - **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end. - **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status. - **next_plan**: Next user plan (resets after use).
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userCreate: UserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('createUser', 'userCreate', userCreate)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create User From Template
         * @param {CreateUserFromTemplate} createUserFromTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFromTemplate: async (createUserFromTemplate: CreateUserFromTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserFromTemplate' is not null or undefined
            assertParamExists('createUserFromTemplate', 'createUserFromTemplate', createUserFromTemplate)
            const localVarPath = `/api/user/from_template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserFromTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided
         * @summary Delete Expired Users
         * @param {string | null} [adminUsername] 
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExpiredUsers: async (adminUsername?: string | null, expiredAfter?: string | null, expiredBefore?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/expired`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (adminUsername !== undefined) {
                localVarQueryParameter['admin_username'] = adminUsername;
            }

            if (expiredAfter !== undefined) {
                localVarQueryParameter['expired_after'] = (expiredAfter as any instanceof Date) ?
                    (expiredAfter as any).toISOString() :
                    expiredAfter;
            }

            if (expiredBefore !== undefined) {
                localVarQueryParameter['expired_before'] = (expiredBefore as any instanceof Date) ?
                    (expiredBefore as any).toISOString() :
                    expiredBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided for filtering - If both are omitted, returns all expired users
         * @summary Get Expired Users
         * @param {string | null} [adminUsername] 
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredUsers: async (adminUsername?: string | null, expiredAfter?: string | null, expiredBefore?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/expired`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (adminUsername !== undefined) {
                localVarQueryParameter['admin_username'] = adminUsername;
            }

            if (expiredAfter !== undefined) {
                localVarQueryParameter['expired_after'] = (expiredAfter as any instanceof Date) ?
                    (expiredAfter as any).toISOString() :
                    expiredAfter;
            }

            if (expiredBefore !== undefined) {
                localVarQueryParameter['expired_before'] = (expiredBefore as any instanceof Date) ?
                    (expiredBefore as any).toISOString() :
                    expiredBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user information
         * @summary Get User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUser', 'username', username)
            const localVarPath = `/api/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user subscription agent list
         * @summary Get User Sub Update List
         * @param {string} username 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubUpdateList: async (username: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserSubUpdateList', 'username', username)
            const localVarPath = `/api/user/{username}/sub_update`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users usage
         * @summary Get User Usage
         * @param {string} username 
         * @param {Period} period 
         * @param {number | null} [nodeId] 
         * @param {boolean} [groupByNode] 
         * @param {string | null} [start] 
         * @param {string | null} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsage: async (username: string, period: Period, nodeId?: number | null, groupByNode?: boolean, start?: string | null, end?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserUsage', 'username', username)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getUserUsage', 'period', period)
            const localVarPath = `/api/user/{username}/usage`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (nodeId !== undefined) {
                localVarQueryParameter['node_id'] = nodeId;
            }

            if (groupByNode !== undefined) {
                localVarQueryParameter['group_by_node'] = groupByNode;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users
         * @summary Get Users
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [username] 
         * @param {Array<string> | null} [admin] 
         * @param {Array<number> | null} [group] 
         * @param {string | null} [search] 
         * @param {UserStatus | null} [status] 
         * @param {string | null} [sort] 
         * @param {string | null} [proxyId] 
         * @param {boolean} [loadSub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (offset?: number, limit?: number, username?: Array<string>, admin?: Array<string> | null, group?: Array<number> | null, search?: string | null, status?: UserStatus | null, sort?: string | null, proxyId?: string | null, loadSub?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (username) {
                localVarQueryParameter['username'] = username;
            }

            if (admin) {
                localVarQueryParameter['admin'] = admin;
            }

            if (group) {
                localVarQueryParameter['group'] = group;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (proxyId !== undefined) {
                localVarQueryParameter['proxy_id'] = proxyId;
            }

            if (loadSub !== undefined) {
                localVarQueryParameter['load_sub'] = loadSub;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get subscription agent distribution percentages (optionally filtered by username)
         * @summary Get Users Sub Update Chart
         * @param {string | null} [username] 
         * @param {number | null} [adminId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSubUpdateChart: async (username?: string | null, adminId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/sub_update/chart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (adminId !== undefined) {
                localVarQueryParameter['admin_id'] = adminId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users usage
         * @summary Get Users Usage
         * @param {Period} period 
         * @param {number | null} [nodeId] 
         * @param {boolean} [groupByNode] 
         * @param {string | null} [start] 
         * @param {string | null} [end] 
         * @param {Array<string> | null} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsage: async (period: Period, nodeId?: number | null, groupByNode?: boolean, start?: string | null, end?: string | null, admin?: Array<string> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getUsersUsage', 'period', period)
            const localVarPath = `/api/users/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (nodeId !== undefined) {
                localVarQueryParameter['node_id'] = nodeId;
            }

            if (groupByNode !== undefined) {
                localVarQueryParameter['group_by_node'] = groupByNode;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (admin) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing user  - **username**: Cannot be changed. Used to identify the user. - **status**: User\'s new status. Can be \'active\', \'disabled\', \'on_hold\', \'limited\', or \'expired\'. - **expire**: UTC datetime for new account expiration. Set to `0` for unlimited, `null` for no change. - **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change. - **data_limit_reset_strategy**: New strategy for data limit reset. Options include \'daily\', \'weekly\', \'monthly\', or \'no_reset\'. - **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change. - **group_ids**: List of new group IDs to assign to the user. Empty list means no change. - **note**: New optional text for additional user information or notes. `null` means no change. - **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to \'on_hold\'. - **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to \'on_hold\'. - **next_plan**: Next user plan (resets after use).  Note: Fields set to `null` or omitted will not be modified.
         * @summary Modify User
         * @param {string} username 
         * @param {UserModify} userModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser: async (username: string, userModify: UserModify, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('modifyUser', 'username', username)
            // verify required parameter 'userModify' is not null or undefined
            assertParamExists('modifyUser', 'userModify', userModify)
            const localVarPath = `/api/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userModify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify User With Template
         * @param {string} username 
         * @param {ModifyUserByTemplate} modifyUserByTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUserWithTemplate: async (username: string, modifyUserByTemplate: ModifyUserByTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('modifyUserWithTemplate', 'username', username)
            // verify required parameter 'modifyUserByTemplate' is not null or undefined
            assertParamExists('modifyUserWithTemplate', 'modifyUserByTemplate', modifyUserByTemplate)
            const localVarPath = `/api/user/from_template/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyUserByTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a user
         * @summary Remove User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('removeUser', 'username', username)
            const localVarPath = `/api/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset user data usage
         * @summary Reset User Data Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserDataUsage: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('resetUserDataUsage', 'username', username)
            const localVarPath = `/api/user/{username}/reset`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset all users data usage
         * @summary Reset Users Data Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUsersDataUsage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke users subscription (Subscription link and proxies)
         * @summary Revoke User Subscription
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserSubscription: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('revokeUserSubscription', 'username', username)
            const localVarPath = `/api/user/{username}/revoke_sub`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a new owner (admin) for a user.
         * @summary Set Owner
         * @param {string} username 
         * @param {string} adminUsername 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOwner: async (username: string, adminUsername: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('setOwner', 'username', username)
            // verify required parameter 'adminUsername' is not null or undefined
            assertParamExists('setOwner', 'adminUsername', adminUsername)
            const localVarPath = `/api/user/{username}/set_owner`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (adminUsername !== undefined) {
                localVarQueryParameter['admin_username'] = adminUsername;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Reset user by next plan
         * @summary Active Next Plan
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activeNextPlan(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeNextPlan(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.activeNextPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk create users from a template using configurable username strategies.  - Includes the template creation fields plus `count`, `strategy`, and `start_number` (for sequences). - **strategy**: Username generation strategy — `sequence` or `random`. - **start_number**: Optional starting suffix for `sequence` strategy. Defaults to `1` and does not parse numbers from the base username.  Returns subscription URLs for created users.
         * @summary Bulk Create Users From Template
         * @param {BulkUsersFromTemplate} bulkUsersFromTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkCreateUsersFromTemplate(bulkUsersFromTemplate: BulkUsersFromTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkUsersCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateUsersFromTemplate(bulkUsersFromTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.bulkCreateUsersFromTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk modify users\' data limit based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
         * @summary Bulk sum/sub to data limit of users
         * @param {BulkUser} bulkUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkModifyUsersDatalimit(bulkUser: BulkUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkModifyUsersDatalimit(bulkUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.bulkModifyUsersDatalimit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk expire users based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (in seconds, positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
         * @summary Bulk sum/sub to expire of users
         * @param {BulkUser} bulkUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkModifyUsersExpire(bulkUser: BulkUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkModifyUsersExpire(bulkUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.bulkModifyUsersExpire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Bulk modify users proxy settings
         * @param {BulkUsersProxy} bulkUsersProxy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkModifyUsersProxySettings(bulkUsersProxy: BulkUsersProxy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkModifyUsersProxySettings(bulkUsersProxy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.bulkModifyUsersProxySettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user  - **username**: 3 to 32 characters, can include a-z, 0-9, and underscores. - **status**: User\'s status, defaults to `active`. Special rules if `on_hold`. - **expire**: UTC datetime for account expiration. Use `0` for unlimited. - **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited. - **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets. - **proxy_settings**: Dictionary of protocol settings (e.g., `vmess`, `vless`) will generate data for all protocol by default. - **group_ids**: List of group IDs to assign to the user. - **note**: Optional text field for additional user information or notes. - **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end. - **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status. - **next_plan**: Next user plan (resets after use).
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userCreate: UserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create User From Template
         * @param {CreateUserFromTemplate} createUserFromTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFromTemplate(createUserFromTemplate: CreateUserFromTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFromTemplate(createUserFromTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createUserFromTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided
         * @summary Delete Expired Users
         * @param {string | null} [adminUsername] 
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExpiredUsers(adminUsername?: string | null, expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExpiredUsers(adminUsername, expiredAfter, expiredBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteExpiredUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided for filtering - If both are omitted, returns all expired users
         * @summary Get Expired Users
         * @param {string | null} [adminUsername] 
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiredUsers(adminUsername?: string | null, expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string | null>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpiredUsers(adminUsername, expiredAfter, expiredBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getExpiredUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user information
         * @summary Get User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user subscription agent list
         * @summary Get User Sub Update List
         * @param {string} username 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSubUpdateList(username: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSubscriptionUpdateList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSubUpdateList(username, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserSubUpdateList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users usage
         * @summary Get User Usage
         * @param {string} username 
         * @param {Period} period 
         * @param {number | null} [nodeId] 
         * @param {boolean} [groupByNode] 
         * @param {string | null} [start] 
         * @param {string | null} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserUsage(username: string, period: Period, nodeId?: number | null, groupByNode?: boolean, start?: string | null, end?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUsageStatsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUsage(username, period, nodeId, groupByNode, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all users
         * @summary Get Users
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [username] 
         * @param {Array<string> | null} [admin] 
         * @param {Array<number> | null} [group] 
         * @param {string | null} [search] 
         * @param {UserStatus | null} [status] 
         * @param {string | null} [sort] 
         * @param {string | null} [proxyId] 
         * @param {boolean} [loadSub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(offset?: number, limit?: number, username?: Array<string>, admin?: Array<string> | null, group?: Array<number> | null, search?: string | null, status?: UserStatus | null, sort?: string | null, proxyId?: string | null, loadSub?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(offset, limit, username, admin, group, search, status, sort, proxyId, loadSub, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get subscription agent distribution percentages (optionally filtered by username)
         * @summary Get Users Sub Update Chart
         * @param {string | null} [username] 
         * @param {number | null} [adminId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersSubUpdateChart(username?: string | null, adminId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSubscriptionUpdateChart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersSubUpdateChart(username, adminId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUsersSubUpdateChart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all users usage
         * @summary Get Users Usage
         * @param {Period} period 
         * @param {number | null} [nodeId] 
         * @param {boolean} [groupByNode] 
         * @param {string | null} [start] 
         * @param {string | null} [end] 
         * @param {Array<string> | null} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUsage(period: Period, nodeId?: number | null, groupByNode?: boolean, start?: string | null, end?: string | null, admin?: Array<string> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUsageStatsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUsage(period, nodeId, groupByNode, start, end, admin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUsersUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify an existing user  - **username**: Cannot be changed. Used to identify the user. - **status**: User\'s new status. Can be \'active\', \'disabled\', \'on_hold\', \'limited\', or \'expired\'. - **expire**: UTC datetime for new account expiration. Set to `0` for unlimited, `null` for no change. - **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change. - **data_limit_reset_strategy**: New strategy for data limit reset. Options include \'daily\', \'weekly\', \'monthly\', or \'no_reset\'. - **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change. - **group_ids**: List of new group IDs to assign to the user. Empty list means no change. - **note**: New optional text for additional user information or notes. `null` means no change. - **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to \'on_hold\'. - **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to \'on_hold\'. - **next_plan**: Next user plan (resets after use).  Note: Fields set to `null` or omitted will not be modified.
         * @summary Modify User
         * @param {string} username 
         * @param {UserModify} userModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyUser(username: string, userModify: UserModify, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyUser(username, userModify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.modifyUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Modify User With Template
         * @param {string} username 
         * @param {ModifyUserByTemplate} modifyUserByTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyUserWithTemplate(username: string, modifyUserByTemplate: ModifyUserByTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyUserWithTemplate(username, modifyUserByTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.modifyUserWithTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a user
         * @summary Remove User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.removeUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset user data usage
         * @summary Reset User Data Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetUserDataUsage(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetUserDataUsage(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.resetUserDataUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset all users data usage
         * @summary Reset Users Data Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetUsersDataUsage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetUsersDataUsage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.resetUsersDataUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke users subscription (Subscription link and proxies)
         * @summary Revoke User Subscription
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeUserSubscription(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeUserSubscription(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.revokeUserSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set a new owner (admin) for a user.
         * @summary Set Owner
         * @param {string} username 
         * @param {string} adminUsername 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOwner(username: string, adminUsername: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOwner(username, adminUsername, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.setOwner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Reset user by next plan
         * @summary Active Next Plan
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeNextPlan(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.activeNextPlan(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk create users from a template using configurable username strategies.  - Includes the template creation fields plus `count`, `strategy`, and `start_number` (for sequences). - **strategy**: Username generation strategy — `sequence` or `random`. - **start_number**: Optional starting suffix for `sequence` strategy. Defaults to `1` and does not parse numbers from the base username.  Returns subscription URLs for created users.
         * @summary Bulk Create Users From Template
         * @param {BulkUsersFromTemplate} bulkUsersFromTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateUsersFromTemplate(bulkUsersFromTemplate: BulkUsersFromTemplate, options?: RawAxiosRequestConfig): AxiosPromise<BulkUsersCreateResponse> {
            return localVarFp.bulkCreateUsersFromTemplate(bulkUsersFromTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk modify users\' data limit based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
         * @summary Bulk sum/sub to data limit of users
         * @param {BulkUser} bulkUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkModifyUsersDatalimit(bulkUser: BulkUser, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.bulkModifyUsersDatalimit(bulkUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk expire users based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (in seconds, positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
         * @summary Bulk sum/sub to expire of users
         * @param {BulkUser} bulkUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkModifyUsersExpire(bulkUser: BulkUser, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.bulkModifyUsersExpire(bulkUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk modify users proxy settings
         * @param {BulkUsersProxy} bulkUsersProxy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkModifyUsersProxySettings(bulkUsersProxy: BulkUsersProxy, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.bulkModifyUsersProxySettings(bulkUsersProxy, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user  - **username**: 3 to 32 characters, can include a-z, 0-9, and underscores. - **status**: User\'s status, defaults to `active`. Special rules if `on_hold`. - **expire**: UTC datetime for account expiration. Use `0` for unlimited. - **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited. - **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets. - **proxy_settings**: Dictionary of protocol settings (e.g., `vmess`, `vless`) will generate data for all protocol by default. - **group_ids**: List of group IDs to assign to the user. - **note**: Optional text field for additional user information or notes. - **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end. - **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status. - **next_plan**: Next user plan (resets after use).
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userCreate: UserCreate, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.createUser(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create User From Template
         * @param {CreateUserFromTemplate} createUserFromTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFromTemplate(createUserFromTemplate: CreateUserFromTemplate, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.createUserFromTemplate(createUserFromTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided
         * @summary Delete Expired Users
         * @param {string | null} [adminUsername] 
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExpiredUsers(adminUsername?: string | null, expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<RemoveUsersResponse> {
            return localVarFp.deleteExpiredUsers(adminUsername, expiredAfter, expiredBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided for filtering - If both are omitted, returns all expired users
         * @summary Get Expired Users
         * @param {string | null} [adminUsername] 
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredUsers(adminUsername?: string | null, expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<string | null>> {
            return localVarFp.getExpiredUsers(adminUsername, expiredAfter, expiredBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user information
         * @summary Get User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user subscription agent list
         * @summary Get User Sub Update List
         * @param {string} username 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubUpdateList(username: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserSubscriptionUpdateList> {
            return localVarFp.getUserSubUpdateList(username, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users usage
         * @summary Get User Usage
         * @param {string} username 
         * @param {Period} period 
         * @param {number | null} [nodeId] 
         * @param {boolean} [groupByNode] 
         * @param {string | null} [start] 
         * @param {string | null} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsage(username: string, period: Period, nodeId?: number | null, groupByNode?: boolean, start?: string | null, end?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserUsageStatsList> {
            return localVarFp.getUserUsage(username, period, nodeId, groupByNode, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users
         * @summary Get Users
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [username] 
         * @param {Array<string> | null} [admin] 
         * @param {Array<number> | null} [group] 
         * @param {string | null} [search] 
         * @param {UserStatus | null} [status] 
         * @param {string | null} [sort] 
         * @param {string | null} [proxyId] 
         * @param {boolean} [loadSub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(offset?: number, limit?: number, username?: Array<string>, admin?: Array<string> | null, group?: Array<number> | null, search?: string | null, status?: UserStatus | null, sort?: string | null, proxyId?: string | null, loadSub?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<UsersResponse> {
            return localVarFp.getUsers(offset, limit, username, admin, group, search, status, sort, proxyId, loadSub, options).then((request) => request(axios, basePath));
        },
        /**
         * Get subscription agent distribution percentages (optionally filtered by username)
         * @summary Get Users Sub Update Chart
         * @param {string | null} [username] 
         * @param {number | null} [adminId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSubUpdateChart(username?: string | null, adminId?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<UserSubscriptionUpdateChart> {
            return localVarFp.getUsersSubUpdateChart(username, adminId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users usage
         * @summary Get Users Usage
         * @param {Period} period 
         * @param {number | null} [nodeId] 
         * @param {boolean} [groupByNode] 
         * @param {string | null} [start] 
         * @param {string | null} [end] 
         * @param {Array<string> | null} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsage(period: Period, nodeId?: number | null, groupByNode?: boolean, start?: string | null, end?: string | null, admin?: Array<string> | null, options?: RawAxiosRequestConfig): AxiosPromise<UserUsageStatsList> {
            return localVarFp.getUsersUsage(period, nodeId, groupByNode, start, end, admin, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing user  - **username**: Cannot be changed. Used to identify the user. - **status**: User\'s new status. Can be \'active\', \'disabled\', \'on_hold\', \'limited\', or \'expired\'. - **expire**: UTC datetime for new account expiration. Set to `0` for unlimited, `null` for no change. - **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change. - **data_limit_reset_strategy**: New strategy for data limit reset. Options include \'daily\', \'weekly\', \'monthly\', or \'no_reset\'. - **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change. - **group_ids**: List of new group IDs to assign to the user. Empty list means no change. - **note**: New optional text for additional user information or notes. `null` means no change. - **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to \'on_hold\'. - **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to \'on_hold\'. - **next_plan**: Next user plan (resets after use).  Note: Fields set to `null` or omitted will not be modified.
         * @summary Modify User
         * @param {string} username 
         * @param {UserModify} userModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser(username: string, userModify: UserModify, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.modifyUser(username, userModify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify User With Template
         * @param {string} username 
         * @param {ModifyUserByTemplate} modifyUserByTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUserWithTemplate(username: string, modifyUserByTemplate: ModifyUserByTemplate, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.modifyUserWithTemplate(username, modifyUserByTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a user
         * @summary Remove User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset user data usage
         * @summary Reset User Data Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserDataUsage(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.resetUserDataUsage(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset all users data usage
         * @summary Reset Users Data Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUsersDataUsage(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.resetUsersDataUsage(options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke users subscription (Subscription link and proxies)
         * @summary Revoke User Subscription
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserSubscription(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.revokeUserSubscription(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a new owner (admin) for a user.
         * @summary Set Owner
         * @param {string} username 
         * @param {string} adminUsername 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOwner(username: string, adminUsername: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.setOwner(username, adminUsername, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Reset user by next plan
     * @summary Active Next Plan
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public activeNextPlan(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).activeNextPlan(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Bulk create users from a template using configurable username strategies.  - Includes the template creation fields plus `count`, `strategy`, and `start_number` (for sequences). - **strategy**: Username generation strategy — `sequence` or `random`. - **start_number**: Optional starting suffix for `sequence` strategy. Defaults to `1` and does not parse numbers from the base username.  Returns subscription URLs for created users.
     * @summary Bulk Create Users From Template
     * @param {BulkUsersFromTemplate} bulkUsersFromTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public bulkCreateUsersFromTemplate(bulkUsersFromTemplate: BulkUsersFromTemplate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).bulkCreateUsersFromTemplate(bulkUsersFromTemplate, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Bulk modify users\' data limit based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
     * @summary Bulk sum/sub to data limit of users
     * @param {BulkUser} bulkUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public bulkModifyUsersDatalimit(bulkUser: BulkUser, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).bulkModifyUsersDatalimit(bulkUser, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Bulk expire users based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (in seconds, positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
     * @summary Bulk sum/sub to expire of users
     * @param {BulkUser} bulkUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public bulkModifyUsersExpire(bulkUser: BulkUser, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).bulkModifyUsersExpire(bulkUser, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * 
     * @summary Bulk modify users proxy settings
     * @param {BulkUsersProxy} bulkUsersProxy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public bulkModifyUsersProxySettings(bulkUsersProxy: BulkUsersProxy, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).bulkModifyUsersProxySettings(bulkUsersProxy, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Create a new user  - **username**: 3 to 32 characters, can include a-z, 0-9, and underscores. - **status**: User\'s status, defaults to `active`. Special rules if `on_hold`. - **expire**: UTC datetime for account expiration. Use `0` for unlimited. - **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited. - **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets. - **proxy_settings**: Dictionary of protocol settings (e.g., `vmess`, `vless`) will generate data for all protocol by default. - **group_ids**: List of group IDs to assign to the user. - **note**: Optional text field for additional user information or notes. - **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end. - **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status. - **next_plan**: Next user plan (resets after use).
     * @summary Create User
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(userCreate: UserCreate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createUser(userCreate, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * 
     * @summary Create User From Template
     * @param {CreateUserFromTemplate} createUserFromTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserFromTemplate(createUserFromTemplate: CreateUserFromTemplate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createUserFromTemplate(createUserFromTemplate, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Delete users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided
     * @summary Delete Expired Users
     * @param {string | null} [adminUsername] 
     * @param {string | null} [expiredAfter] 
     * @param {string | null} [expiredBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteExpiredUsers(adminUsername?: string | null, expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteExpiredUsers(adminUsername, expiredAfter, expiredBefore, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided for filtering - If both are omitted, returns all expired users
     * @summary Get Expired Users
     * @param {string | null} [adminUsername] 
     * @param {string | null} [expiredAfter] 
     * @param {string | null} [expiredBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getExpiredUsers(adminUsername?: string | null, expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getExpiredUsers(adminUsername, expiredAfter, expiredBefore, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get user information
     * @summary Get User
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get user subscription agent list
     * @summary Get User Sub Update List
     * @param {string} username 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserSubUpdateList(username: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserSubUpdateList(username, offset, limit, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get users usage
     * @summary Get User Usage
     * @param {string} username 
     * @param {Period} period 
     * @param {number | null} [nodeId] 
     * @param {boolean} [groupByNode] 
     * @param {string | null} [start] 
     * @param {string | null} [end] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserUsage(username: string, period: Period, nodeId?: number | null, groupByNode?: boolean, start?: string | null, end?: string | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserUsage(username, period, nodeId, groupByNode, start, end, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get all users
     * @summary Get Users
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {Array<string>} [username] 
     * @param {Array<string> | null} [admin] 
     * @param {Array<number> | null} [group] 
     * @param {string | null} [search] 
     * @param {UserStatus | null} [status] 
     * @param {string | null} [sort] 
     * @param {string | null} [proxyId] 
     * @param {boolean} [loadSub] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(offset?: number, limit?: number, username?: Array<string>, admin?: Array<string> | null, group?: Array<number> | null, search?: string | null, status?: UserStatus | null, sort?: string | null, proxyId?: string | null, loadSub?: boolean, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers(offset, limit, username, admin, group, search, status, sort, proxyId, loadSub, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get subscription agent distribution percentages (optionally filtered by username)
     * @summary Get Users Sub Update Chart
     * @param {string | null} [username] 
     * @param {number | null} [adminId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersSubUpdateChart(username?: string | null, adminId?: number | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsersSubUpdateChart(username, adminId, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get all users usage
     * @summary Get Users Usage
     * @param {Period} period 
     * @param {number | null} [nodeId] 
     * @param {boolean} [groupByNode] 
     * @param {string | null} [start] 
     * @param {string | null} [end] 
     * @param {Array<string> | null} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersUsage(period: Period, nodeId?: number | null, groupByNode?: boolean, start?: string | null, end?: string | null, admin?: Array<string> | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsersUsage(period, nodeId, groupByNode, start, end, admin, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Modify an existing user  - **username**: Cannot be changed. Used to identify the user. - **status**: User\'s new status. Can be \'active\', \'disabled\', \'on_hold\', \'limited\', or \'expired\'. - **expire**: UTC datetime for new account expiration. Set to `0` for unlimited, `null` for no change. - **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change. - **data_limit_reset_strategy**: New strategy for data limit reset. Options include \'daily\', \'weekly\', \'monthly\', or \'no_reset\'. - **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change. - **group_ids**: List of new group IDs to assign to the user. Empty list means no change. - **note**: New optional text for additional user information or notes. `null` means no change. - **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to \'on_hold\'. - **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to \'on_hold\'. - **next_plan**: Next user plan (resets after use).  Note: Fields set to `null` or omitted will not be modified.
     * @summary Modify User
     * @param {string} username 
     * @param {UserModify} userModify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public modifyUser(username: string, userModify: UserModify, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).modifyUser(username, userModify, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * 
     * @summary Modify User With Template
     * @param {string} username 
     * @param {ModifyUserByTemplate} modifyUserByTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public modifyUserWithTemplate(username: string, modifyUserByTemplate: ModifyUserByTemplate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).modifyUserWithTemplate(username, modifyUserByTemplate, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Remove a user
     * @summary Remove User
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public removeUser(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).removeUser(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Reset user data usage
     * @summary Reset User Data Usage
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resetUserDataUsage(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).resetUserDataUsage(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Reset all users data usage
     * @summary Reset Users Data Usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resetUsersDataUsage(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).resetUsersDataUsage(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Revoke users subscription (Subscription link and proxies)
     * @summary Revoke User Subscription
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public revokeUserSubscription(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).revokeUserSubscription(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Set a new owner (admin) for a user.
     * @summary Set Owner
     * @param {string} username 
     * @param {string} adminUsername 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setOwner(username: string, adminUsername: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).setOwner(username, adminUsername, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }
}

