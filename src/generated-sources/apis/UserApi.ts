/* tslint:disable */
/* eslint-disable */
/**
 * PasarGuardAPI
 * Unified GUI Censorship Resistant Solution
 *
 * The version of the OpenAPI document: 1.11.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BulkUser,
  BulkUsersCreateResponse,
  BulkUsersFromTemplate,
  BulkUsersProxy,
  Conflict,
  CreateUserFromTemplate,
  Forbidden,
  HTTPException,
  HTTPValidationError,
  ModifyUserByTemplate,
  NotFound,
  Period,
  RemoveUsersResponse,
  Unauthorized,
  UserCreate,
  UserModify,
  UserResponse,
  UserStatus,
  UserSubscriptionUpdateChart,
  UserSubscriptionUpdateList,
  UserUsageStatsList,
  UsersResponse,
} from '../models/index';
import {
    BulkUserFromJSON,
    BulkUserToJSON,
    BulkUsersCreateResponseFromJSON,
    BulkUsersCreateResponseToJSON,
    BulkUsersFromTemplateFromJSON,
    BulkUsersFromTemplateToJSON,
    BulkUsersProxyFromJSON,
    BulkUsersProxyToJSON,
    ConflictFromJSON,
    ConflictToJSON,
    CreateUserFromTemplateFromJSON,
    CreateUserFromTemplateToJSON,
    ForbiddenFromJSON,
    ForbiddenToJSON,
    HTTPExceptionFromJSON,
    HTTPExceptionToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    ModifyUserByTemplateFromJSON,
    ModifyUserByTemplateToJSON,
    NotFoundFromJSON,
    NotFoundToJSON,
    PeriodFromJSON,
    PeriodToJSON,
    RemoveUsersResponseFromJSON,
    RemoveUsersResponseToJSON,
    UnauthorizedFromJSON,
    UnauthorizedToJSON,
    UserCreateFromJSON,
    UserCreateToJSON,
    UserModifyFromJSON,
    UserModifyToJSON,
    UserResponseFromJSON,
    UserResponseToJSON,
    UserStatusFromJSON,
    UserStatusToJSON,
    UserSubscriptionUpdateChartFromJSON,
    UserSubscriptionUpdateChartToJSON,
    UserSubscriptionUpdateListFromJSON,
    UserSubscriptionUpdateListToJSON,
    UserUsageStatsListFromJSON,
    UserUsageStatsListToJSON,
    UsersResponseFromJSON,
    UsersResponseToJSON,
} from '../models/index';

export interface ActiveNextPlanRequest {
    username: string;
}

export interface BulkCreateUsersFromTemplateRequest {
    bulkUsersFromTemplate: BulkUsersFromTemplate;
}

export interface BulkModifyUsersDatalimitRequest {
    bulkUser: BulkUser;
}

export interface BulkModifyUsersExpireRequest {
    bulkUser: BulkUser;
}

export interface BulkModifyUsersProxySettingsRequest {
    bulkUsersProxy: BulkUsersProxy;
}

export interface CreateUserRequest {
    userCreate: UserCreate;
}

export interface CreateUserFromTemplateRequest {
    createUserFromTemplate: CreateUserFromTemplate;
}

export interface DeleteExpiredUsersRequest {
    adminUsername?: string | null;
    expiredAfter?: Date | null;
    expiredBefore?: Date | null;
}

export interface GetExpiredUsersRequest {
    adminUsername?: string | null;
    expiredAfter?: Date | null;
    expiredBefore?: Date | null;
}

export interface GetUserRequest {
    username: string;
}

export interface GetUserSubUpdateListRequest {
    username: string;
    offset?: number;
    limit?: number;
}

export interface GetUserUsageRequest {
    username: string;
    period: Period;
    nodeId?: number | null;
    groupByNode?: boolean;
    start?: Date | null;
    end?: Date | null;
}

export interface GetUsersRequest {
    offset?: number;
    limit?: number;
    username?: Array<string>;
    admin?: Array<string> | null;
    group?: Array<number> | null;
    search?: string | null;
    status?: UserStatus | null;
    sort?: string | null;
    proxyId?: string | null;
    loadSub?: boolean;
}

export interface GetUsersSubUpdateChartRequest {
    username?: string | null;
    adminId?: number | null;
}

export interface GetUsersUsageRequest {
    period: Period;
    nodeId?: number | null;
    groupByNode?: boolean;
    start?: Date | null;
    end?: Date | null;
    admin?: Array<string> | null;
}

export interface ModifyUserRequest {
    username: string;
    userModify: UserModify;
}

export interface ModifyUserWithTemplateRequest {
    username: string;
    modifyUserByTemplate: ModifyUserByTemplate;
}

export interface RemoveUserRequest {
    username: string;
}

export interface ResetUserDataUsageRequest {
    username: string;
}

export interface RevokeUserSubscriptionRequest {
    username: string;
}

export interface SetOwnerRequest {
    username: string;
    adminUsername: string;
}

/**
 * 
 */
export class UserApi extends runtime.BaseAPI {

    /**
     * Reset user by next plan
     * Active Next Plan
     */
    async activeNextPlanRaw(requestParameters: ActiveNextPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling activeNextPlan().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/{username}/active_next`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Reset user by next plan
     * Active Next Plan
     */
    async activeNextPlan(requestParameters: ActiveNextPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.activeNextPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk create users from a template using configurable username strategies.  - Includes the template creation fields plus `count`, `strategy`, and `start_number` (for sequences). - **strategy**: Username generation strategy — `sequence` or `random`. - **start_number**: Optional starting suffix for `sequence` strategy. Defaults to `1` and does not parse numbers from the base username.  Returns subscription URLs for created users.
     * Bulk Create Users From Template
     */
    async bulkCreateUsersFromTemplateRaw(requestParameters: BulkCreateUsersFromTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BulkUsersCreateResponse>> {
        if (requestParameters['bulkUsersFromTemplate'] == null) {
            throw new runtime.RequiredError(
                'bulkUsersFromTemplate',
                'Required parameter "bulkUsersFromTemplate" was null or undefined when calling bulkCreateUsersFromTemplate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/users/bulk/from_template`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BulkUsersFromTemplateToJSON(requestParameters['bulkUsersFromTemplate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BulkUsersCreateResponseFromJSON(jsonValue));
    }

    /**
     * Bulk create users from a template using configurable username strategies.  - Includes the template creation fields plus `count`, `strategy`, and `start_number` (for sequences). - **strategy**: Username generation strategy — `sequence` or `random`. - **start_number**: Optional starting suffix for `sequence` strategy. Defaults to `1` and does not parse numbers from the base username.  Returns subscription URLs for created users.
     * Bulk Create Users From Template
     */
    async bulkCreateUsersFromTemplate(requestParameters: BulkCreateUsersFromTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BulkUsersCreateResponse> {
        const response = await this.bulkCreateUsersFromTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk modify users\' data limit based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
     * Bulk sum/sub to data limit of users
     */
    async bulkModifyUsersDatalimitRaw(requestParameters: BulkModifyUsersDatalimitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['bulkUser'] == null) {
            throw new runtime.RequiredError(
                'bulkUser',
                'Required parameter "bulkUser" was null or undefined when calling bulkModifyUsersDatalimit().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/users/bulk/data_limit`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BulkUserToJSON(requestParameters['bulkUser']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Bulk modify users\' data limit based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
     * Bulk sum/sub to data limit of users
     */
    async bulkModifyUsersDatalimit(requestParameters: BulkModifyUsersDatalimitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.bulkModifyUsersDatalimitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk expire users based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (in seconds, positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
     * Bulk sum/sub to expire of users
     */
    async bulkModifyUsersExpireRaw(requestParameters: BulkModifyUsersExpireRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['bulkUser'] == null) {
            throw new runtime.RequiredError(
                'bulkUser',
                'Required parameter "bulkUser" was null or undefined when calling bulkModifyUsersExpire().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/users/bulk/expire`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BulkUserToJSON(requestParameters['bulkUser']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Bulk expire users based on the provided criteria.  - **amount**: amount to adjust the user\'s quota (in seconds, positive to increase, negative to decrease) required - **user_ids**: Optional list of user IDs to modify - **admins**: Optional list of admin IDs — their users will be targeted - **status**: Optional status to filter users (e.g., \"expired\", \"active\"), Empty means no filtering - **group_ids**: Optional list of group IDs to filter users by their group membership
     * Bulk sum/sub to expire of users
     */
    async bulkModifyUsersExpire(requestParameters: BulkModifyUsersExpireRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.bulkModifyUsersExpireRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk modify users proxy settings
     */
    async bulkModifyUsersProxySettingsRaw(requestParameters: BulkModifyUsersProxySettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['bulkUsersProxy'] == null) {
            throw new runtime.RequiredError(
                'bulkUsersProxy',
                'Required parameter "bulkUsersProxy" was null or undefined when calling bulkModifyUsersProxySettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/users/bulk/proxy_settings`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BulkUsersProxyToJSON(requestParameters['bulkUsersProxy']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Bulk modify users proxy settings
     */
    async bulkModifyUsersProxySettings(requestParameters: BulkModifyUsersProxySettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.bulkModifyUsersProxySettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new user  - **username**: 3 to 32 characters, can include a-z, 0-9, and underscores. - **status**: User\'s status, defaults to `active`. Special rules if `on_hold`. - **expire**: UTC datetime for account expiration. Use `0` for unlimited. - **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited. - **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets. - **proxy_settings**: Dictionary of protocol settings (e.g., `vmess`, `vless`) will generate data for all protocol by default. - **group_ids**: List of group IDs to assign to the user. - **note**: Optional text field for additional user information or notes. - **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end. - **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status. - **next_plan**: Next user plan (resets after use).
     * Create User
     */
    async createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters['userCreate'] == null) {
            throw new runtime.RequiredError(
                'userCreate',
                'Required parameter "userCreate" was null or undefined when calling createUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserCreateToJSON(requestParameters['userCreate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Create a new user  - **username**: 3 to 32 characters, can include a-z, 0-9, and underscores. - **status**: User\'s status, defaults to `active`. Special rules if `on_hold`. - **expire**: UTC datetime for account expiration. Use `0` for unlimited. - **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited. - **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets. - **proxy_settings**: Dictionary of protocol settings (e.g., `vmess`, `vless`) will generate data for all protocol by default. - **group_ids**: List of group IDs to assign to the user. - **note**: Optional text field for additional user information or notes. - **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end. - **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status. - **next_plan**: Next user plan (resets after use).
     * Create User
     */
    async createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.createUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create User From Template
     */
    async createUserFromTemplateRaw(requestParameters: CreateUserFromTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters['createUserFromTemplate'] == null) {
            throw new runtime.RequiredError(
                'createUserFromTemplate',
                'Required parameter "createUserFromTemplate" was null or undefined when calling createUserFromTemplate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/from_template`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateUserFromTemplateToJSON(requestParameters['createUserFromTemplate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Create User From Template
     */
    async createUserFromTemplate(requestParameters: CreateUserFromTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.createUserFromTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided
     * Delete Expired Users
     */
    async deleteExpiredUsersRaw(requestParameters: DeleteExpiredUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RemoveUsersResponse>> {
        const queryParameters: any = {};

        if (requestParameters['adminUsername'] != null) {
            queryParameters['admin_username'] = requestParameters['adminUsername'];
        }

        if (requestParameters['expiredAfter'] != null) {
            queryParameters['expired_after'] = (requestParameters['expiredAfter'] as any).toISOString();
        }

        if (requestParameters['expiredBefore'] != null) {
            queryParameters['expired_before'] = (requestParameters['expiredBefore'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/users/expired`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RemoveUsersResponseFromJSON(jsonValue));
    }

    /**
     * Delete users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided
     * Delete Expired Users
     */
    async deleteExpiredUsers(requestParameters: DeleteExpiredUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RemoveUsersResponse> {
        const response = await this.deleteExpiredUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided for filtering - If both are omitted, returns all expired users
     * Get Expired Users
     */
    async getExpiredUsersRaw(requestParameters: GetExpiredUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string | null>>> {
        const queryParameters: any = {};

        if (requestParameters['adminUsername'] != null) {
            queryParameters['admin_username'] = requestParameters['adminUsername'];
        }

        if (requestParameters['expiredAfter'] != null) {
            queryParameters['expired_after'] = (requestParameters['expiredAfter'] as any).toISOString();
        }

        if (requestParameters['expiredBefore'] != null) {
            queryParameters['expired_before'] = (requestParameters['expiredBefore'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/users/expired`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided for filtering - If both are omitted, returns all expired users
     * Get Expired Users
     */
    async getExpiredUsers(requestParameters: GetExpiredUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string | null>> {
        const response = await this.getExpiredUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get user information
     * Get User
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling getUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Get user information
     * Get User
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get user subscription agent list
     * Get User Sub Update List
     */
    async getUserSubUpdateListRaw(requestParameters: GetUserSubUpdateListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSubscriptionUpdateList>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling getUserSubUpdateList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/{username}/sub_update`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSubscriptionUpdateListFromJSON(jsonValue));
    }

    /**
     * Get user subscription agent list
     * Get User Sub Update List
     */
    async getUserSubUpdateList(requestParameters: GetUserSubUpdateListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSubscriptionUpdateList> {
        const response = await this.getUserSubUpdateListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get users usage
     * Get User Usage
     */
    async getUserUsageRaw(requestParameters: GetUserUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserUsageStatsList>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling getUserUsage().'
            );
        }

        if (requestParameters['period'] == null) {
            throw new runtime.RequiredError(
                'period',
                'Required parameter "period" was null or undefined when calling getUserUsage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['period'] != null) {
            queryParameters['period'] = requestParameters['period'];
        }

        if (requestParameters['nodeId'] != null) {
            queryParameters['node_id'] = requestParameters['nodeId'];
        }

        if (requestParameters['groupByNode'] != null) {
            queryParameters['group_by_node'] = requestParameters['groupByNode'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = (requestParameters['start'] as any).toISOString();
        }

        if (requestParameters['end'] != null) {
            queryParameters['end'] = (requestParameters['end'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/{username}/usage`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserUsageStatsListFromJSON(jsonValue));
    }

    /**
     * Get users usage
     * Get User Usage
     */
    async getUserUsage(requestParameters: GetUserUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserUsageStatsList> {
        const response = await this.getUserUsageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all users
     * Get Users
     */
    async getUsersRaw(requestParameters: GetUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersResponse>> {
        const queryParameters: any = {};

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['username'] != null) {
            queryParameters['username'] = requestParameters['username'];
        }

        if (requestParameters['admin'] != null) {
            queryParameters['admin'] = requestParameters['admin'];
        }

        if (requestParameters['group'] != null) {
            queryParameters['group'] = requestParameters['group'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['proxyId'] != null) {
            queryParameters['proxy_id'] = requestParameters['proxyId'];
        }

        if (requestParameters['loadSub'] != null) {
            queryParameters['load_sub'] = requestParameters['loadSub'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersResponseFromJSON(jsonValue));
    }

    /**
     * Get all users
     * Get Users
     */
    async getUsers(requestParameters: GetUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersResponse> {
        const response = await this.getUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get subscription agent distribution percentages (optionally filtered by username)
     * Get Users Sub Update Chart
     */
    async getUsersSubUpdateChartRaw(requestParameters: GetUsersSubUpdateChartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSubscriptionUpdateChart>> {
        const queryParameters: any = {};

        if (requestParameters['username'] != null) {
            queryParameters['username'] = requestParameters['username'];
        }

        if (requestParameters['adminId'] != null) {
            queryParameters['admin_id'] = requestParameters['adminId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/users/sub_update/chart`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSubscriptionUpdateChartFromJSON(jsonValue));
    }

    /**
     * Get subscription agent distribution percentages (optionally filtered by username)
     * Get Users Sub Update Chart
     */
    async getUsersSubUpdateChart(requestParameters: GetUsersSubUpdateChartRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSubscriptionUpdateChart> {
        const response = await this.getUsersSubUpdateChartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all users usage
     * Get Users Usage
     */
    async getUsersUsageRaw(requestParameters: GetUsersUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserUsageStatsList>> {
        if (requestParameters['period'] == null) {
            throw new runtime.RequiredError(
                'period',
                'Required parameter "period" was null or undefined when calling getUsersUsage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['period'] != null) {
            queryParameters['period'] = requestParameters['period'];
        }

        if (requestParameters['nodeId'] != null) {
            queryParameters['node_id'] = requestParameters['nodeId'];
        }

        if (requestParameters['groupByNode'] != null) {
            queryParameters['group_by_node'] = requestParameters['groupByNode'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = (requestParameters['start'] as any).toISOString();
        }

        if (requestParameters['end'] != null) {
            queryParameters['end'] = (requestParameters['end'] as any).toISOString();
        }

        if (requestParameters['admin'] != null) {
            queryParameters['admin'] = requestParameters['admin'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/users/usage`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserUsageStatsListFromJSON(jsonValue));
    }

    /**
     * Get all users usage
     * Get Users Usage
     */
    async getUsersUsage(requestParameters: GetUsersUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserUsageStatsList> {
        const response = await this.getUsersUsageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify an existing user  - **username**: Cannot be changed. Used to identify the user. - **status**: User\'s new status. Can be \'active\', \'disabled\', \'on_hold\', \'limited\', or \'expired\'. - **expire**: UTC datetime for new account expiration. Set to `0` for unlimited, `null` for no change. - **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change. - **data_limit_reset_strategy**: New strategy for data limit reset. Options include \'daily\', \'weekly\', \'monthly\', or \'no_reset\'. - **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change. - **group_ids**: List of new group IDs to assign to the user. Empty list means no change. - **note**: New optional text for additional user information or notes. `null` means no change. - **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to \'on_hold\'. - **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to \'on_hold\'. - **next_plan**: Next user plan (resets after use).  Note: Fields set to `null` or omitted will not be modified.
     * Modify User
     */
    async modifyUserRaw(requestParameters: ModifyUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling modifyUser().'
            );
        }

        if (requestParameters['userModify'] == null) {
            throw new runtime.RequiredError(
                'userModify',
                'Required parameter "userModify" was null or undefined when calling modifyUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserModifyToJSON(requestParameters['userModify']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Modify an existing user  - **username**: Cannot be changed. Used to identify the user. - **status**: User\'s new status. Can be \'active\', \'disabled\', \'on_hold\', \'limited\', or \'expired\'. - **expire**: UTC datetime for new account expiration. Set to `0` for unlimited, `null` for no change. - **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change. - **data_limit_reset_strategy**: New strategy for data limit reset. Options include \'daily\', \'weekly\', \'monthly\', or \'no_reset\'. - **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change. - **group_ids**: List of new group IDs to assign to the user. Empty list means no change. - **note**: New optional text for additional user information or notes. `null` means no change. - **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to \'on_hold\'. - **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to \'on_hold\'. - **next_plan**: Next user plan (resets after use).  Note: Fields set to `null` or omitted will not be modified.
     * Modify User
     */
    async modifyUser(requestParameters: ModifyUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.modifyUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify User With Template
     */
    async modifyUserWithTemplateRaw(requestParameters: ModifyUserWithTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling modifyUserWithTemplate().'
            );
        }

        if (requestParameters['modifyUserByTemplate'] == null) {
            throw new runtime.RequiredError(
                'modifyUserByTemplate',
                'Required parameter "modifyUserByTemplate" was null or undefined when calling modifyUserWithTemplate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/from_template/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModifyUserByTemplateToJSON(requestParameters['modifyUserByTemplate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Modify User With Template
     */
    async modifyUserWithTemplate(requestParameters: ModifyUserWithTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.modifyUserWithTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a user
     * Remove User
     */
    async removeUserRaw(requestParameters: RemoveUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling removeUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a user
     * Remove User
     */
    async removeUser(requestParameters: RemoveUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeUserRaw(requestParameters, initOverrides);
    }

    /**
     * Reset user data usage
     * Reset User Data Usage
     */
    async resetUserDataUsageRaw(requestParameters: ResetUserDataUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling resetUserDataUsage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/{username}/reset`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Reset user data usage
     * Reset User Data Usage
     */
    async resetUserDataUsage(requestParameters: ResetUserDataUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.resetUserDataUsageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reset all users data usage
     * Reset Users Data Usage
     */
    async resetUsersDataUsageRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/users/reset`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Reset all users data usage
     * Reset Users Data Usage
     */
    async resetUsersDataUsage(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.resetUsersDataUsageRaw(initOverrides);
        return await response.value();
    }

    /**
     * Revoke users subscription (Subscription link and proxies)
     * Revoke User Subscription
     */
    async revokeUserSubscriptionRaw(requestParameters: RevokeUserSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling revokeUserSubscription().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/{username}/revoke_sub`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Revoke users subscription (Subscription link and proxies)
     * Revoke User Subscription
     */
    async revokeUserSubscription(requestParameters: RevokeUserSubscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.revokeUserSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set a new owner (admin) for a user.
     * Set Owner
     */
    async setOwnerRaw(requestParameters: SetOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling setOwner().'
            );
        }

        if (requestParameters['adminUsername'] == null) {
            throw new runtime.RequiredError(
                'adminUsername',
                'Required parameter "adminUsername" was null or undefined when calling setOwner().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['adminUsername'] != null) {
            queryParameters['admin_username'] = requestParameters['adminUsername'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/user/{username}/set_owner`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Set a new owner (admin) for a user.
     * Set Owner
     */
    async setOwner(requestParameters: SetOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.setOwnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
